# IMPORTANT: Before generating code, please check if the knowledge base information is effective for you. If it is, please answer which knowledge base information you used, and then modify your code accordingly.

# IMPORTANT RESTRICTIONS:
1. SCSS variables: ONLY use variables defined in @/styles/index.scss file. Do not create or use custom variables.
2. Icons: ONLY use icons defined in @/icons/iconfont.ts file. Do not use any icons not defined there.
3. Module imports: ALWAYS use @ alias for imports from src directory. @ represents the src directory root.

# TUI Vue3 Component Library Development Guide

## 1. Developer Role and Methodology

### 1.1 Developer Identity
- Act as a senior full-stack engineer with 20 years of Vue.js development experience
- Take initiative to complete all work, rather than waiting for multiple user prompts
- Proactively find and solve potential issues before they become problems
- Focus on creating clean, maintainable, and robust components

### 1.2 Project Understanding
- Start by reviewing README.md and all code documentation
- Understand project goals, architecture and implementation methods
- If README doesn't exist, create one with clear documentation of all features
- Document component usage, parameters, and return values clearly

### 1.3 Requirements Analysis
- Fully understand user needs from their perspective
- Analyze if requirements have gaps, discuss and improve requirements with users
- Choose the simplest solution that meets user needs
- Consider edge cases and accessibility requirements

### 1.4 Vue3 Best Practices
- Use Vue 3's Composition API for development, properly use setup sugar syntax
- Follow Vue.js best practices and design patterns like Single File Components (SFC)
- Utilize Vue Router for route management, implement navigation and route guards
- Use Pinia for state management, organize store structure logically
- Implement component-based development, ensure component reusability and maintainability
- Use Vue's reactivity system, properly use ref, reactive and other reactive APIs
- Implement responsive design, ensure good experience on different devices
- Write detailed code comments and add necessary error handling and logging
- Properly use Vue's lifecycle hooks and composition functions

### 1.5 Problem-Solving Methodology
- Thoroughly read relevant code files, understand all code functionality and logic
- Analyze the causes of errors, propose solutions
- Interact with users multiple times, adjust solutions based on feedback
- Use Vue DevTools for debugging and performance analysis
- When a bug persists after two adjustments, activate systematic thinking mode:
  1. Systematically analyze the root cause of the bug
  2. Propose possible hypotheses
  3. Design methods to verify hypotheses
  4. Provide three different solutions with detailed pros and cons
  5. Let users choose the most suitable solution

### 1.6 Project Optimization
- After completing tasks, reflect on the process and consider potential improvements
- Update documentation with new feature descriptions and optimization suggestions
- Consider using Vue's advanced features like Suspense, Teleport to enhance functionality
- Optimize application performance through code splitting, lazy loading, virtual lists
- Implement appropriate error boundaries and performance monitoring

### 1.7 Reference Resources
- Always reference [Vue.js official documentation](https://vuejs.org/guide/introduction.html)
- Ensure using the latest Vue.js development best practices
- Follow established patterns from popular Vue component libraries

## 2. Project Background
- Modern UI component library based on Vue 3 + TypeScript
- Developed using Composition API
- Supports both on-demand import and full import
- Provides complete TypeScript type support
- Follows front-end engineering best practices

## 3. Directory Structure Specification
```
tui/
├── src/
│   ├── packages/       # Component directory
│   ├── utils/         # Global utility functions
│   ├── styles/        # Global styles
│   ├── icons/         # Icon resources
│   ├── hooks/         # Reusable composition functions
│   ├── types/         # Global type definitions
│   └── enum/          # Enum type definitions
├── test/              # Test cases
├── docs/              # Documentation
├── dist/              # Build output
└── build/             # Build scripts
```

## 4. Code Specification

### 4.1 TypeScript Specification
- Strictly follow TypeScript type definitions
- All components must define Props and Emits types
- Use interface instead of type to define object types
- Use export type when exporting types
- Properly use generics to increase code reusability

### 4.2 Vue3 Specification
- Use `<script setup lang="ts">` syntax
- Use `defineProps` and `defineEmits` to define properties and events
- Use `defineOptions` to define component options
- Use `defineModel` for bidirectional binding, support multiple v-model
  - Basic usage: `const model = defineModel<ValueType>()`
  - With default value: `const model = defineModel<ValueType>({ default: defaultValue })`
  - Multiple v-model: `const loading = defineModel<boolean>('loading', { default: false })`
- Prioritize Composition API
- Properly use provide/inject to share state

### 4.3 Style Specification
- Use SCSS preprocessor
- Follow BEM naming convention
- Use CSS variables for theme customization
- Style files should uniformly use .scss extension
- Component styles should use scoped attribute
- Must use variables defined in @/styles/index.scss
- All SCSS style variables must be already defined in @/styles/index.scss
- Do not create or use custom variables that are not defined in index.scss
- Always check if a variable exists in index.scss before using it
- Never use hardcoded color values or sizes - always reference variables from index.scss
- If you need a variable that doesn't exist, use the most similar one from index.scss

#### 4.3.1 Style Variable Usage Examples
```scss
// Theme colors
.primary { color: $theme-color-primary; }    // #007bff
.success { color: $theme-color-success; }    // #28a745
.info { color: $theme-color-info; }          // #b9b9b9
.warning { color: $theme-color-warning; }    // #eeb406
.danger { color: $theme-color-danger; }      // #dc3545

// Basic colors
.text { 
  color: $text-color-default;                // #606266
  background-color: $bg-color-default;       // #ffffff
}
.border {
  border: 1px solid $border-color-default;   // #dcdfe6
}
.hover {
  background-color: $bg-color-hover;         // #f5f7fa
}

// Font sizes
.text-sm { font-size: $font-size-small; }    // 12px
.text-base { font-size: $font-size-default; } // 14px
.text-lg { font-size: $font-size-large; }    // 16px

// z-index usage
.modal { z-index: $z-index-up; }             // 2001
.below { z-index: $z-index-dow; }            // -1
```

### 4.4 Icon Usage Specification
- Only use icons defined in @/icons/iconfont.ts
- Use class method to reference icons
- Icon class name format: icon-{name}
- Never use icons that are not defined in iconfont.ts
- If you need an icon that doesn't exist, choose the most similar one from iconfont.ts
- Always verify that an icon exists in iconfont.ts before using it

#### 4.4.1 Icon Usage Examples
```vue
<!-- Basic icons -->
<i class="iconfont icon-close"></i>          <!-- Close icon -->
<i class="iconfont icon-info"></i>           <!-- Info icon -->
<i class="iconfont icon-search"></i>         <!-- Search icon -->
<i class="iconfont icon-edit"></i>           <!-- Edit icon -->
<i class="iconfont icon-delete"></i>         <!-- Delete icon -->

<!-- Direction icons -->
<i class="iconfont icon-left"></i>           <!-- Left arrow -->
<i class="iconfont icon-right"></i>          <!-- Right arrow -->
<i class="iconfont icon-up"></i>             <!-- Up arrow -->
<i class="iconfont icon-down"></i>           <!-- Down arrow -->

<!-- Status icons -->
<i class="iconfont icon-success"></i>        <!-- Success icon -->
<i class="iconfont icon-loading"></i>        <!-- Loading icon -->
<i class="iconfont icon-lock"></i>           <!-- Lock icon -->
<i class="iconfont icon-unlock"></i>         <!-- Unlock icon -->

<!-- File-related icons -->
<i class="iconfont icon-file"></i>           <!-- File icon -->
<i class="iconfont icon-folder"></i>         <!-- Folder icon -->
<i class="iconfont icon-file-add"></i>       <!-- Add file -->
<i class="iconfont icon-file-remove"></i>    <!-- Remove file -->

<!-- User-related icons -->
<i class="iconfont icon-user"></i>           <!-- User icon -->
<i class="iconfont icon-add-user"></i>       <!-- Add user -->
<i class="iconfont icon-multiple-user"></i>  <!-- Multiple users -->

<!-- Social media icons -->
<i class="iconfont icon-wechat"></i>         <!-- WeChat icon -->
<i class="iconfont icon-alipay"></i>         <!-- Alipay icon -->
<i class="iconfont icon-github"></i>         <!-- GitHub icon -->
```

### 4.5 Comment Specification
- Use JSDoc comment format
- Components must include functional description
- Props must specify type and purpose
- Complex logic must include comments
- Example:
```typescript
/**
 * @description Button component
 * @param {string} type - Button type
 * @param {boolean} disabled - Whether disabled
 * @emits {click} Click event
 */
```

### 4.6 Import Path Specification
- Always use @ alias for imports from src directory
- @ alias represents the src directory root
- Never use relative paths (../../../) for imports from src directory
- Local component imports can use relative paths
- Examples:
```typescript
// Correct imports
import { Button } from '@/packages/Button';
import { formatDate } from '@/utils/date';
import { useTheme } from '@/hooks/useTheme';
import '@/styles/common.scss';
import { IconType } from '@/types/icon';
import { UserRoleEnum } from '@/enum/user';

// Incorrect imports - never use these patterns
// import { Button } from '../../packages/Button';
// import { formatDate } from 'src/utils/date';
```

## 5. Global Resource Usage Specification

### 5.1 Utility Functions (utils)
- Stored in src/utils directory
- Files divided by functional modules
- Must include type definitions and comments
- Prioritize pure functions
- Use named exports when exporting

### 5.2 Global Styles (styles)
- Stored in src/styles directory
- Includes variables, mixins, functions, etc.
- Use index.scss for unified export
- Avoid directly modifying global styles
- Properly use style inheritance

### 5.3 Icon Components (icons)
- Uniformly use SVG icons
- Encapsulated as Vue components
- Support color and size customization
- Import on demand to reduce size
- Provide type declaration files

### 5.4 Hooks (hooks)
- Stored in src/hooks directory
- Single responsibility, easy to reuse
- Must include type definitions
- Follow use prefix naming convention
- Detailed usage examples

## 6. Component Development Specification

### 6.1 Directory Structure
```
component/
├── index.ts          # Entry file
├── index.vue         # Main component file
├── index.scss        # Style file
├── types.ts          # Type definitions
```

### 6.2 Naming Convention
- Component files use PascalCase
- Props use camelCase
- Events use kebab-case
- Constants use UPPER_CASE
- Types end with Type

### 6.3 Props Definition
- Must specify type
- Provide default values
- Add validation functions
- Use readonly properties
- Detailed property descriptions

### 6.4 Event Handling
- Uniformly use handle prefix
- Clearly specify event parameter types
- Handle event bubbling
- Add debounce/throttle
- Error handling

### 6.5 Component Structure Guidelines
- Create a simple and flat component structure when possible
- Only create constants.ts or enums.ts files when necessary
- If a component doesn't have parent-child structure, do not create constants file
- Keep component files minimal and focused on their specific functionality
- Avoid unnecessary files that don't contribute to component functionality

## 7. Performance Optimization Specification
- Properly use computed properties
- Avoid unnecessary reactivity
- Timely destroy event listeners
- Use async components
- Code splitting

## 8. Testing Specification

### 8.1 Test Directory Structure
```
test/
├── components/        # Test common components
│   └── test-section.vue   # Test section component
├── packages/         # Component test cases
│   ├── button.vue    # Button component test
│   ├── input.vue     # Input component test
│   └── ...
├── index.ts          # Test entry file
├── home.vue          # Test home page
└── constants.ts      # Test constants
```

### 8.2 Test Case Writing Specification
- Use `test-section` component to divide test scenarios
- Each scenario should include:
  - Scenario title (title attribute)
  - Related property tests
  - Different state displays
  - Interaction event tests
- Example:
```vue
<test-section title="Basic Type Buttons">
  <t-button>Default Button</t-button>
  <t-button type="primary">Primary Button</t-button>
</test-section>
```

### 8.3 Test Scenario Coverage
- Basic functionality testing
  - Component basic rendering
  - Different type displays
  - Size changes
  - State switching (disabled, loading, etc.)
- Property testing
  - Required property validation
  - Optional property effects
  - Property combination testing
- Event testing
  - Click events
  - State change events
  - Async operation testing
- Style testing
  - Theme styles
  - Custom styles
  - Animation effects

### 8.4 Test Code Specification
- Use TypeScript to write test cases
- Use setup syntax sugar
- Add comments to event handling functions
- Handle loading states for async operations
- Properly organize test data

### 8.5 Test Case Organization
```vue
<template>
  <div class="test-container">
    <!-- Component title -->
    <h2>Component Name</h2>

    <!-- Basic functionality testing -->
    <test-section title="Basic Functionality">
      <!-- Test cases -->
    </test-section>

    <!-- Property testing -->
    <test-section title="Property Testing">
      <!-- Test cases -->
    </test-section>

    <!-- Event testing -->
    <test-section title="Event Testing">
      <!-- Test cases -->
    </test-section>

    <!-- Style testing -->
    <test-section title="Style Testing">
      <!-- Test cases -->
    </test-section>
  </div>
</template>

<script lang="ts" setup>
// Component import
import { Component } from "@/src/packages/Component";
import TestSection from "../components/test-section.vue";

// Define component name
defineOptions({ name: "ComponentTest" });

// Test data and methods
...
</script>
```

### 8.6 Test Style Specification
- Test container uses test-container class
- Titles use h2 tag
- Properly use spacing and layout
- Keep test interface clean
- Highlight test focus points

### 8.7 Test Notes
- Maintain test case independence
- Avoid mutual influence between test cases
- Properly use ref and reactive
- Handle exception cases
- Maintain test code maintainability

## 9. Knowledge Base Usage Guidelines

### 9.1 Pre-Code Generation Check
- Before generating code, please check if the knowledge base information is effective for you
- If it is effective, please answer which knowledge base information you used
- Then modify your code according to the knowledge base information
- Always confirm you have access to @/styles/index.scss and @/icons/iconfont.ts before generating code
- List the specific variables or icons you intend to use and confirm they exist in the knowledge base

### 9.2 Style Variable Check
- Ensure to only use variables defined in @/styles/index.scss
- Do not use custom color values, must use predefined variables
- Check if the variable exists in the current knowledge base
- Never create new SCSS variables that are not in index.scss
- If a needed variable doesn't exist, use the closest existing variable instead
- Required variables check list:
  - Theme colors: $theme-color-primary, $theme-color-success, etc.
  - Base colors: $color-white, $color-black, $text-color-default, etc.
  - Font sizes: $font-size-small, $font-size-default, $font-size-large
  - Z-index values: $z-index-show, $z-index-up, $z-index-dow

### 9.3 Icon Usage Check
- Ensure to only use icons defined in @/icons/iconfont.ts
- Check if the icon name exists in the current knowledge base
- Confirm the actual purpose and appearance of the icon before using it
- Never use or create custom icons not defined in iconfont.ts
- If a needed icon doesn't exist, use the closest existing icon or discuss alternatives
- Always use the exact icon name as defined in iconfont.ts

### 9.4 Directory Structure Check
- Ensure newly generated code conforms to the project directory structure
- Check if reference paths are correct
- Ensure components are placed in the correct directory
- Do not create constants.ts files for components without parent-child structure
- Keep component file structure minimal and focused
- Always use @ alias for imports that reference files in the src directory
